Жизненный цикл бинов.
1) Парсирование конфигурации и создание BeanDefinition.
- Xml конфигурация - ClassPathXmlApplicationContext("context.xml")
- Конфигурация через аннотации с указанием пакета для сканирования - AnnotationConfigApplicationContext(
"package.name")
- Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration
- AnnotationConfigApplicationContext(JavaConfig.class). Это способ конфигурации называется JavaConfig
- Groovy конфигурация - GenericGroovyApplicationContext("context.groovy").

Если заглянуть внутрь AnnotationConfigApplicationContext, то можно увидеть два поля.
private final AnnotatedBeanDefinitionReader reader;
private final ClassPathBeanDefinitionScanner scanner;

ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией
@Component(или её алиаса). Найденные классы парсируются и для них создаются BeanDefinition. Чтобы было
запущено сканирование, в конфигурации должен быть указан пакет для сканирования @ComponentScan({"package.name"}).

AnnotationBeanDefinitionReader работает в несколько этапов.
1. Первый этап - это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации
используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернёт true.
2. Второй этап - это регистрация BeanDefinitionRegistryPostProcessor, который при помощи класса
ConfigurationClassPostProcessor парсирует JavaConfig и создаёт BeanDefinition.

Цель первого этапа - это создание всех BeanDefinition. BeanDefinition - это специальный интерфейс, через
который можно получить доступ к метаданным будущего бина. В зависимости от того, какая у вас конфигурация,
будет использоваться тот или иной механизм парсирования конфигурации.

BeanDefinition - это набор метаданных будущего бина, макет, по которому нужно будет создавать бин
в случае необходимости. То есть для каждого бина создаётся свой BeanDefinition, в котором хранится
описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе -
столько и объектов BeanDefinition, их описывающих.
Сюда входит: из какого класса бин надо создать, scope, установлена ли ленивая инициализация, нужно ли
перед данным бином инициализировать другой, init и destroy методы, зависимости.
Все полученные BeanDefinition`ы складываются в ConcurrentHashMap, в которой ключом является имя бина,
а объект - сам BeanDefinition.

При старте приложения в IoC контейнер попадут бины, которые имеют scope Singleton (устанавливается по-умолчанию),
остальные же создаются, тогда когда они нужны.
_______________________________
2) Настройка созданных BeanDefinition.
Есть возможность повлиять на бины до их создания, иначе говоря мы имеем ввиду доступ к метаданным класса.
Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ
к созданным BeanDefinition и можем их изменять. В нём один метод.
Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит
много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все
BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки
метаданных.
Разберём одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе
данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они
загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания
экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе,
который реализует интерфейс BeanFactoryPostProcessor.
Название этого класса - PropertySourcesPlaceholderConfigurer. Он должен быть объявлен как static

@Bean
public static PropertySourcesPlaceholderConfigurer configurer() {
    return new PropertySourcesPlaceholderConfigurer();
}
_______________________________
3) Создание кастомных FactoryBean (только для XML-конфигурации).
FactoryBean - это generic интерфейс, которому можно делегировать процесс создания бинов типа.
В те времена, когда конфигурация была исключительно в xml, разработчикам был необходим механизм с помощью
которого они бы могли управлять процессом создания бинов. Именно для этого и был сделан этот интерфейс.
Создадим фабрику, которая будет отвечать за создание всех бинов типа - Color.

public class ColorFactory implements FactoryBean<Color> {
    @Override
    public Color getObject() throws Exception {
        Random random = new Random();
        return new Color(random.nextInt(), random.nextInt(), random.nextInt());
    }

    @Override
    public Class<?> getObjectType() {
        return Color.class;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}

Теперь создания бина типа Color.class будет делегироваться ColorFactory, у которого при каждом создании
нового бина будет вызываться метод getObject.
Для тех кто пользуется JavaConfig, этот интерфейс будет абсолютно бесполезен.
_______________________________
4) Создание экземпляров бинов.
Сначала BeanFactory из коллекции Map с объектами BeanDefinition достаёт те из них, из которых создаёт
все BeanPostProcessor-ы (Инфраструктурные бины), необходимые для настройки обычных бинов.
Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition.
Созданием экземпляров бинов занимается BeanFactory на основе раннее созданных BeanDefinition.
Из Map<BeanName, BeanDefinition> получаем Map<BeanName, Bean>
Создание бинов может делегироваться кастомным FactoryBean.
_______________________________
5) Настройка созданных бинов
На данном этапе бины уже созданы, мы можем их донастроить.
Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки ваших бинов до того, как они попадут
в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и
помечает их как "post-processors-ов", которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource.
Интерфейс несёт в себе два метода: postProcessBeforeInitialization(Object bean, String beanName) и
postProcessAfterInitialization(Object bean, String beanName). У обоих методов параметры абсолютно одинаковые.
Разница только в порядке их вызова. Первый вызывается до init-метода, второй - после.
Как правило, BeanPostProcessor-ы, которые заполняют бины через маркерные интерфейсы или тому подобное,
реализовывают метод postProcessBeforeInitialization(Object bean, String beanName),
тогда как BeanPostProcessor-ы, которые оборачивают бины в прокси, обычно реализуют
postProcessAfterInitialization(Object bean, String beanName).

Прокси - это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже
скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить
оригинальный класс так, чтобы никто не заметил подмены.
Есть два варианта создания этого класса:
1. Либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя
нужную логику;
2. Либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).
По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать
на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина,
работает на оригинальный метод, до того, как на него накрутится прокси.
_______________________________
